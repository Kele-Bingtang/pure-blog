(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{568:function(v,_,e){"use strict";e.r(_);var l=e(3),o=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#创建一个新序列-它"}},[v._v("创建一个新序列，它")])]),_("li",[_("a",{attrs:{href:"#对序列进行转化"}},[v._v("对序列进行转化")])]),_("li",[_("a",{attrs:{href:"#窥视-只读-序列"}},[v._v("窥视（只读）序列")]),_("ul",[_("li",[_("a",{attrs:{href:"#过滤序列"}},[v._v("过滤序列")])])])]),_("li",[_("a",{attrs:{href:"#错误处理"}},[v._v("错误处理")])]),_("li",[_("a",{attrs:{href:"#基于时间的操作"}},[v._v("基于时间的操作")])]),_("li",[_("a",{attrs:{href:"#拆分-flux"}},[v._v("拆分 Flux")])]),_("li",[_("a",{attrs:{href:"#回到同步的世界"}},[v._v("回到同步的世界")])])])]),_("p"),v._v(" "),_("blockquote",[_("p",[v._v("本内容里，如果一个操作符是专属于 "),_("code",[v._v("Flux")]),v._v(" 或 "),_("code",[v._v("Mono")]),v._v(" 的，那么会给它注明前缀。 公共的操作符没有前缀。如果一个具体的用例涉及多个操作符的组合，这里以方法调用的方式展现， 会以一个点（.）开头，并将参数置于圆括号内，比如："),_("code",[v._v(".methodCall(parameter)")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"创建一个新序列-它"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#创建一个新序列-它"}},[v._v("#")]),v._v(" 创建一个新序列，它")]),v._v(" "),_("ul",[_("li",[v._v("发出一个 "),_("code",[v._v("T")]),v._v("，我已经有了："),_("code",[v._v("just")]),v._v(" "),_("ul",[_("li",[v._v("基于一个 "),_("code",[v._v("Optional<T>")]),v._v("："),_("code",[v._v("Mono#justOrEmpty(Optional<T>)")])]),v._v(" "),_("li",[v._v("基于一个可能为 "),_("code",[v._v("null")]),v._v(" 的 T："),_("code",[v._v("Mono#justOrEmpty(T)")])])])]),v._v(" "),_("li",[v._v("发出一个 "),_("code",[v._v("T")]),v._v("，且还是由 "),_("code",[v._v("just")]),v._v(" 方法返回\n"),_("ul",[_("li",[v._v("但是「懒」创建的：使用 "),_("code",[v._v("Mono#fromSupplier")]),v._v(" 或用 "),_("code",[v._v("defer")]),v._v(" 包装 "),_("code",[v._v("just")])])])]),v._v(" "),_("li",[v._v("发出许多 "),_("code",[v._v("T")]),v._v("，这些元素我可以明确列举出来："),_("code",[v._v("Flux#just(T...)")])]),v._v(" "),_("li",[v._v("基于迭代数据结构:\n"),_("ul",[_("li",[v._v("一个数组："),_("code",[v._v("Flux#fromArray")])]),v._v(" "),_("li",[v._v("一个集合或 iterable："),_("code",[v._v("Flux#fromIterable")])]),v._v(" "),_("li",[v._v("一个 Integer 的 range："),_("code",[v._v("Flux#range")])]),v._v(" "),_("li",[v._v("一个 "),_("code",[v._v("Stream")]),v._v(" 提供给每一个订阅："),_("code",[v._v("Flux#fromStream(Supplier<Stream>)")])])])]),v._v(" "),_("li",[v._v("基于一个参数值给出的源：\n"),_("ul",[_("li",[v._v("一个 "),_("code",[v._v("Supplier<T>")]),v._v("："),_("code",[v._v("Mono#fromSupplier")])]),v._v(" "),_("li",[v._v("一个任务："),_("code",[v._v("Mono#fromCallable")]),v._v("，"),_("code",[v._v("Mono#fromRunnable")])]),v._v(" "),_("li",[v._v("一个 "),_("code",[v._v("CompletableFuture<T>")]),v._v("："),_("code",[v._v("Mono#fromFuture")])])])]),v._v(" "),_("li",[v._v("直接完成："),_("code",[v._v("empty")])]),v._v(" "),_("li",[v._v("立即生成错误："),_("code",[v._v("error")]),v._v(" "),_("ul",[_("li",[v._v("但是「懒」的方式生成 "),_("code",[v._v("Throwable")]),v._v("："),_("code",[v._v("error(Supplier<Throwable>)")])])])]),v._v(" "),_("li",[v._v("什么都不做："),_("code",[v._v("never")])]),v._v(" "),_("li",[v._v("订阅时才决定："),_("code",[v._v("defer")])]),v._v(" "),_("li",[v._v("依赖一个可回收的资源："),_("code",[v._v("using")])]),v._v(" "),_("li",[v._v("可编程地生成事件（可以使用状态）:\n"),_("ul",[_("li",[v._v("同步且逐个的："),_("code",[v._v("Flux#generate")])]),v._v(" "),_("li",[v._v("异步（也可同步）的，每次尽可能多发出元素："),_("code",[v._v("Flux#create")]),v._v(" （"),_("code",[v._v("Mono#create")]),v._v(" 也是异步的，只不过只能发一个）")])])])]),v._v(" "),_("h2",{attrs:{id:"对序列进行转化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对序列进行转化"}},[v._v("#")]),v._v(" 对序列进行转化")]),v._v(" "),_("ul",[_("li",[v._v("我想转化一个序列：\n"),_("ul",[_("li",[v._v("1对1地转化（比如字符串转化为它的长度）："),_("code",[v._v("map")]),v._v(" "),_("ul",[_("li",[v._v("类型转化："),_("code",[v._v("cast")])]),v._v(" "),_("li",[v._v("为了获得每个元素的序号："),_("code",[v._v("Flux#index")])])])]),v._v(" "),_("li",[v._v("1对n地转化（如字符串转化为一串字符）："),_("code",[v._v("flatMap")]),v._v(" + 使用一个工厂方法")]),v._v(" "),_("li",[v._v("1对n地转化可自定义转化方法和/或状态："),_("code",[v._v("handle")])]),v._v(" "),_("li",[v._v("对每一个元素执行一个异步操作（如对 url 执行 http 请求）："),_("code",[v._v("flatMap")]),v._v(" + 一个异步的返回类型为 "),_("code",[v._v("Publisher")]),v._v(" 的方法\n"),_("ul",[_("li",[v._v("忽略一些数据：在 flatMap lambda 中根据条件返回一个 "),_("code",[v._v("Mono.empty()")])]),v._v(" "),_("li",[v._v("保留原来的序列顺序："),_("code",[v._v("Flux#flatMapSequential")]),v._v("（对每个元素的异步任务会立即执行，但会将结果按照原序列顺序排序）")]),v._v(" "),_("li",[v._v("当 Mono 元素的异步任务会返回多个元素的序列时："),_("code",[v._v("Mono#flatMapMany")])])])])])]),v._v(" "),_("li",[v._v("我想添加一些数据元素到一个现有的序列：\n"),_("ul",[_("li",[v._v("在开头添加："),_("code",[v._v("Flux#startWith(T...)")])]),v._v(" "),_("li",[v._v("在最后添加："),_("code",[v._v("Flux#concatWith(T...)")])])])]),v._v(" "),_("li",[v._v("我想将 "),_("code",[v._v("Flux")]),v._v(" 转化为集合（一下都是针对 "),_("code",[v._v("Flux")]),v._v(" 的）\n"),_("ul",[_("li",[v._v("转化为 List："),_("code",[v._v("collectList")]),v._v("，"),_("code",[v._v("collectSortedList")])]),v._v(" "),_("li",[v._v("转化为 Map："),_("code",[v._v("collectMap")]),v._v("，"),_("code",[v._v("collectMultiMap")])]),v._v(" "),_("li",[v._v("转化为自定义集合："),_("code",[v._v("collect")])]),v._v(" "),_("li",[v._v("计数："),_("code",[v._v("count")])]),v._v(" "),_("li",[v._v("reduce 算法（将上个元素的reduce结果与当前元素值作为输入执行reduce方法，如sum） "),_("code",[v._v("reduce")]),v._v(" "),_("ul",[_("li",[v._v("将每次 reduce 的结果立即发出："),_("code",[v._v("scan")])])])]),v._v(" "),_("li",[v._v("转化为一个 boolean 值：\n"),_("ul",[_("li",[v._v("对所有元素判断都为true："),_("code",[v._v("all")])]),v._v(" "),_("li",[v._v("对至少一个元素判断为true："),_("code",[v._v("any")])]),v._v(" "),_("li",[v._v("判断序列是否有元素（不为空）："),_("code",[v._v("hasElements")])]),v._v(" "),_("li",[v._v("判断序列中是否有匹配的元素："),_("code",[v._v("hasElement")])])])])])]),v._v(" "),_("li",[v._v("我想合并 publishers\n"),_("ul",[_("li",[v._v("按序连接："),_("code",[v._v("Flux#concat")]),v._v(" 或 "),_("code",[v._v(".concatWith(other)")]),v._v(" "),_("ul",[_("li",[v._v("即使有错误，也会等所有的 publishers 连接完成："),_("code",[v._v("Flux#concatDelayError")])]),v._v(" "),_("li",[v._v("按订阅顺序连接（这里的合并仍然可以理解成序列的连接）："),_("code",[v._v("Flux#mergeSequential")])])])]),v._v(" "),_("li",[v._v("按元素发出的顺序合并（无论哪个序列的，元素先到先合并）："),_("code",[v._v("Flux#merge")]),v._v(" / "),_("code",[v._v(".mergeWith(other)")]),v._v(" "),_("ul",[_("li",[v._v("元素类型会发生变化："),_("code",[v._v("Flux#zip")]),v._v(" / "),_("code",[v._v("Flux#zipWith")])])])]),v._v(" "),_("li",[v._v("将元素组合：\n"),_("ul",[_("li",[v._v("2个 Monos 组成1个 "),_("code",[v._v("Tuple2")]),v._v("："),_("code",[v._v("Mono#zipWith")])]),v._v(" "),_("li",[v._v("n个 Monos 的元素都发出来后组成一个 Tuple："),_("code",[v._v("Mono#zip")])])])]),v._v(" "),_("li",[v._v("在终止信号出现时「采取行动」：\n"),_("ul",[_("li",[v._v("在 Mono 终止时转换为一个 "),_("code",[v._v("Mono<Void>")]),v._v("："),_("code",[v._v("Mono#and")])]),v._v(" "),_("li",[v._v("当 n 个 Mono 都终止时返回 "),_("code",[v._v("Mono<Void>")]),v._v("："),_("code",[v._v("Mono#when")])]),v._v(" "),_("li",[v._v("返回一个存放组合数据的类型，对于被合并的多个序列：\n"),_("ul",[_("li",[v._v("每个序列都发出一个元素时："),_("code",[v._v("Flux#zip")])]),v._v(" "),_("li",[v._v("任何一个序列发出元素时："),_("code",[v._v("Flux#combineLatest")])])])])])]),v._v(" "),_("li",[v._v("只取各个序列的第一个元素："),_("code",[v._v("Flux#first")]),v._v("，"),_("code",[v._v("Mono#first")]),v._v("，"),_("code",[v._v("mono.or (otherMono).or(thirdMono)")]),v._v("，`flux.or(otherFlux).or(thirdFlux)")]),v._v(" "),_("li",[v._v("由一个序列触发（类似于 "),_("code",[v._v("flatMap")]),v._v("，不过「喜新厌旧」）："),_("code",[v._v("switchMap")])]),v._v(" "),_("li",[v._v("由每个新序列开始时触发（也是「喜新厌旧」风格）："),_("code",[v._v("switchOnNext")])])])]),v._v(" "),_("li",[v._v("我想重复一个序列："),_("code",[v._v("repeat")]),v._v(" "),_("ul",[_("li",[v._v("但是以一定的间隔重复："),_("code",[v._v("Flux.interval(duration).flatMap(tick -> myExistingPublisher)")])])])]),v._v(" "),_("li",[v._v("我有一个空序列，但是\n"),_("ul",[_("li",[v._v("我想要一个缺省值来代替："),_("code",[v._v("defaultIfEmpty")])]),v._v(" "),_("li",[v._v("我想要一个缺省的序列来代替："),_("code",[v._v("switchIfEmpty")])])])]),v._v(" "),_("li",[v._v("我有一个序列，但是我对序列的元素值不感兴趣："),_("code",[v._v("ignoreElements")]),v._v(" "),_("ul",[_("li",[v._v("并且我希望用 "),_("code",[v._v("Mono")]),v._v(" 来表示序列已经结束："),_("code",[v._v("then")])]),v._v(" "),_("li",[v._v("并且我想在序列结束后等待另一个任务完成："),_("code",[v._v("thenEmpty")])]),v._v(" "),_("li",[v._v("并且我想在序列结束之后返回一个 "),_("code",[v._v("Mono")]),v._v("："),_("code",[v._v("Mono#then(mono)")])]),v._v(" "),_("li",[v._v("并且我想在序列结束之后返回一个值："),_("code",[v._v("Mono#thenReturn(T)")])]),v._v(" "),_("li",[v._v("并且我想在序列结束之后返回一个 "),_("code",[v._v("Flux")]),v._v("："),_("code",[v._v("thenMany")])])])]),v._v(" "),_("li",[v._v("我有一个 Mono 但我想延迟完成\n"),_("ul",[_("li",[v._v("当有1个或N个其他 publishers 都发出（或结束）时才完成："),_("code",[v._v("Mono#delayUntilOther")]),v._v(" "),_("ul",[_("li",[v._v("使用一个函数式来定义如何获取「其他 publisher」："),_("code",[v._v("Mono#delayUntil(Function)")])])])])])]),v._v(" "),_("li",[v._v("我想基于一个递归的生成序列的规则扩展每一个元素，然后合并为一个序列发出：\n"),_("ul",[_("li",[v._v("广度优先："),_("code",[v._v("expand(Function)")])]),v._v(" "),_("li",[v._v("深度优先："),_("code",[v._v("expandDeep(Function)")])])])])]),v._v(" "),_("h2",{attrs:{id:"窥视-只读-序列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#窥视-只读-序列"}},[v._v("#")]),v._v(" 窥视（只读）序列")]),v._v(" "),_("ul",[_("li",[v._v("再不对序列造成改变的情况下，我想：\n"),_("ul",[_("li",[v._v("得到通知或执行一些操作：\n"),_("ul",[_("li",[v._v("发出元素："),_("code",[v._v("doOnNext")])]),v._v(" "),_("li",[v._v("序列完成："),_("code",[v._v("Flux#doOnComplete")]),v._v("，"),_("code",[v._v("Mono#doOnSuccess")])]),v._v(" "),_("li",[v._v("因错误终止："),_("code",[v._v("doOnError")])]),v._v(" "),_("li",[v._v("取消："),_("code",[v._v("doOnCancel")])]),v._v(" "),_("li",[v._v("订阅时："),_("code",[v._v("doOnSubscribe")])]),v._v(" "),_("li",[v._v("请求时："),_("code",[v._v("doOnRequest")])]),v._v(" "),_("li",[v._v("完成或错误终止："),_("code",[v._v("doOnTerminate")]),v._v("（Mono的方法可能包含有结果）\n"),_("ul",[_("li",[v._v("但是在终止信号向下游传递 "),_("strong",[v._v("之后")]),v._v(" ："),_("code",[v._v("doAfterTerminate")])])])]),v._v(" "),_("li",[v._v("所有类型的信号（"),_("code",[v._v("Signal")]),v._v("）："),_("code",[v._v("Flux#doOnEach")])]),v._v(" "),_("li",[v._v("所有结束的情况（完成complete、错误error、取消cancel）："),_("code",[v._v("doFinally")])])])]),v._v(" "),_("li",[v._v("记录日志："),_("code",[v._v("log")])])])]),v._v(" "),_("li",[v._v("我想知道所有的事件:\n"),_("ul",[_("li",[v._v("每一个事件都体现为一个 "),_("code",[v._v("single")]),v._v(" 对象：\n"),_("ul",[_("li",[v._v("执行 callback："),_("code",[v._v("doOnEach")])]),v._v(" "),_("li",[v._v("每个元素转化为 "),_("code",[v._v("single")]),v._v(" 对象："),_("code",[v._v("materialize")]),v._v(" "),_("ul",[_("li",[v._v("在转化回元素："),_("code",[v._v("dematerialize")])])])])])]),v._v(" "),_("li",[v._v("转化为一行日志："),_("code",[v._v("log")])])])])]),v._v(" "),_("h3",{attrs:{id:"过滤序列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#过滤序列"}},[v._v("#")]),v._v(" 过滤序列")]),v._v(" "),_("ul",[_("li",[v._v("我想过滤一个序列\n"),_("ul",[_("li",[v._v("基于给定的判断条件："),_("code",[v._v("filter")]),v._v(" "),_("ul",[_("li",[v._v("异步地进行判断："),_("code",[v._v("filterWhen")])])])]),v._v(" "),_("li",[v._v("仅限于指定类型的对象："),_("code",[v._v("ofType")])]),v._v(" "),_("li",[v._v("忽略所有元素："),_("code",[v._v("ignoreElements")])]),v._v(" "),_("li",[v._v("去重:\n"),_("ul",[_("li",[v._v("对于整个序列："),_("code",[v._v("Flux#distinct")])]),v._v(" "),_("li",[v._v("去掉连续重复的元素："),_("code",[v._v("Flux#distinctUntilChanged")])])])])])]),v._v(" "),_("li",[v._v("我只想要一部分序列：\n"),_("ul",[_("li",[v._v("只要 N 个元素：\n"),_("ul",[_("li",[v._v("从序列的第一个元素开始算："),_("code",[v._v("Flux#take(long)")]),v._v(" "),_("ul",[_("li",[v._v("取一段时间内发出的元素："),_("code",[v._v("Flux#take(Duration)")])]),v._v(" "),_("li",[v._v("只取第一个元素放到 "),_("code",[v._v("Mono")]),v._v(" 中返回："),_("code",[v._v("Flux#next()")])]),v._v(" "),_("li",[v._v("使用 "),_("code",[v._v("request(N)")]),v._v(" 而不是取消："),_("code",[v._v("Flux#limitRequest(long)")])])])]),v._v(" "),_("li",[v._v("从序列的最后一个元素倒数："),_("code",[v._v("Flux#takeLast")])]),v._v(" "),_("li",[v._v("直到满足某个条件（包含）："),_("code",[v._v("Flux#takeUntil")]),v._v("（基于判断条件），"),_("code",[v._v("Flux#takeUntilOther")]),v._v("（基于对 publisher 的比较）")]),v._v(" "),_("li",[v._v("直到满足某个条件（不包含）："),_("code",[v._v("Flux#takeWhile")])])])]),v._v(" "),_("li",[v._v("最多只取 1 个元素：\n"),_("ul",[_("li",[v._v("给定序号："),_("code",[v._v("Flux#elementAt")])]),v._v(" "),_("li",[v._v("最后一个："),_("code",[v._v(".takeLast(1)")]),v._v(" "),_("ul",[_("li",[v._v("如果为序列空则发出错误信号："),_("code",[v._v("Flux#last()")])]),v._v(" "),_("li",[v._v("如果序列为空则返回默认值："),_("code",[v._v("Flux#last(T)")])])])])])]),v._v(" "),_("li",[v._v("跳过一些元素：\n"),_("ul",[_("li",[v._v("从序列的第一个元素开始跳过："),_("code",[v._v("Flux#skip(long)")]),v._v(" "),_("ul",[_("li",[v._v("跳过一段时间内发出的元素："),_("code",[v._v("Flux#skip(Duration)")])])])]),v._v(" "),_("li",[v._v("跳过最后的 n 个元素："),_("code",[v._v("Flux#skipLast")])]),v._v(" "),_("li",[v._v("直到满足某个条件（包含）："),_("code",[v._v("Flux#skipUntil")]),v._v("（基于判断条件），"),_("code",[v._v("Flux#skipUntilOther")]),v._v(" （基于对 publisher 的比较）")]),v._v(" "),_("li",[v._v("直到满足某个条件（不包含）："),_("code",[v._v("Flux#skipWhile")])])])]),v._v(" "),_("li",[v._v("采样：\n"),_("ul",[_("li",[v._v("给定采样周期："),_("code",[v._v("Flux#sample(Duration)")]),v._v(" "),_("ul",[_("li",[v._v("取采样周期里的第一个元素而不是最后一个："),_("code",[v._v("sampleFirst")])])])]),v._v(" "),_("li",[v._v("基于另一个 publisher："),_("code",[v._v("Flux#sample(Publisher)")])]),v._v(" "),_("li",[v._v("基于 publisher「超时」："),_("code",[v._v("Flux#sampleTimeout")]),v._v(" （每一个元素会触发一个 publisher，如果这个 publisher 不被下一个元素触发的 publisher 覆盖就发出这个元素）")])])])])]),v._v(" "),_("li",[v._v("我只想要一个元素（如果多于一个就返回错误）\n"),_("ul",[_("li",[v._v("如果序列为空，发出错误信号："),_("code",[v._v("Flux#single()")])]),v._v(" "),_("li",[v._v("如果序列为空，发出一个缺省值："),_("code",[v._v("Flux#single(T)")])]),v._v(" "),_("li",[v._v("如果序列为空就返回一个空序列："),_("code",[v._v("Flux#singleOrEmpty")])])])])]),v._v(" "),_("h2",{attrs:{id:"错误处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[v._v("#")]),v._v(" 错误处理")]),v._v(" "),_("ul",[_("li",[v._v("我想创建一个错误序列："),_("code",[v._v("error")]),v._v(" "),_("ul",[_("li",[v._v("替换一个完成的 "),_("code",[v._v("Flux")]),v._v("："),_("code",[v._v(".concat(Flux.error(e))")])]),v._v(" "),_("li",[v._v("替换一个完成的 "),_("code",[v._v("Mono")]),v._v("："),_("code",[v._v(".then(Mono.error(e))")])]),v._v(" "),_("li",[v._v("如果元素超时未发出："),_("code",[v._v("timeout")])]),v._v(" "),_("li",[v._v("「懒」创建："),_("code",[v._v("error(Supplier<Throwable>)")])])])]),v._v(" "),_("li",[v._v("我想要类似 try/catch 的表达方式：\n"),_("ul",[_("li",[v._v("抛出异常："),_("code",[v._v("error")])]),v._v(" "),_("li",[v._v("捕获异常：\n"),_("ul",[_("li",[v._v("然后返回缺省值："),_("code",[v._v("onErrorReturn")])]),v._v(" "),_("li",[v._v("然后返回一个 "),_("code",[v._v("Flux")]),v._v(" 或 "),_("code",[v._v("Mono")]),v._v("："),_("code",[v._v("onErrorResume")])]),v._v(" "),_("li",[v._v("包装异常后再抛出："),_("code",[v._v(".onErrorMap(t -> new RuntimeException(t))")])])])]),v._v(" "),_("li",[v._v("finally 代码块："),_("code",[v._v("doFinally")])]),v._v(" "),_("li",[v._v("Java 7 之后的 try-with-resources 写法："),_("code",[v._v("using")]),v._v(" 工厂方法")])])]),v._v(" "),_("li",[v._v("我想从错误中恢复\n"),_("ul",[_("li",[v._v("返回一个缺省的：\n"),_("ul",[_("li",[v._v("的值："),_("code",[v._v("onErrorReturn")])]),v._v(" "),_("li",[_("code",[v._v("Publisher")]),v._v("："),_("code",[v._v("Flux#onErrorResume")]),v._v(" 和 "),_("code",[v._v("Mono#onErrorResume")])])])]),v._v(" "),_("li",[v._v("重试："),_("code",[v._v("retry")]),v._v(" "),_("ul",[_("li",[v._v("由一个用于伴随 Flux 触发："),_("code",[v._v("retryWhen")])])])])])]),v._v(" "),_("li",[v._v("我想处理回压错误（向上游发出「MAX」的 request，如果下游的 request 比较少，则应用策略）\n"),_("ul",[_("li",[v._v("抛出 "),_("code",[v._v("IllegalStateException")]),v._v("："),_("code",[v._v("Flux#onBackpressureError")])]),v._v(" "),_("li",[v._v("丢弃策略："),_("code",[v._v("Flux#onBackpressureDrop")]),v._v(" "),_("ul",[_("li",[v._v("但是不丢弃最后一个元素："),_("code",[v._v("Flux#onBackpressureLatest")])])])]),v._v(" "),_("li",[v._v("缓存策略（有限或无限）："),_("code",[v._v("Flux#onBackpressureBuffer")]),v._v(" "),_("ul",[_("li",[v._v("当有限的缓存空间用满则应用给定策略："),_("code",[v._v("Flux#onBackpressureBuffer")]),v._v(" 带有策略 "),_("code",[v._v("BufferOverflowStrategy")])])])])])])]),v._v(" "),_("h2",{attrs:{id:"基于时间的操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基于时间的操作"}},[v._v("#")]),v._v(" 基于时间的操作")]),v._v(" "),_("ul",[_("li",[v._v("我想将元素转换为带有时间信息的 "),_("code",[v._v("Tuple2<Long, T>")]),v._v(" "),_("ul",[_("li",[v._v("从订阅时开始："),_("code",[v._v("elapsed")])]),v._v(" "),_("li",[v._v("记录时间戳："),_("code",[v._v("timestamp")])])])]),v._v(" "),_("li",[v._v("如果元素间延迟过长则中止序列："),_("code",[v._v("timeout")])]),v._v(" "),_("li",[v._v("以固定的周期发出元素："),_("code",[v._v("Flux#interval")])]),v._v(" "),_("li",[v._v("在一个给定的延迟后发出 "),_("code",[v._v("0")]),v._v("：static "),_("code",[v._v("Mono.delay")]),v._v(".")]),v._v(" "),_("li",[v._v("我想引入延迟：\n"),_("ul",[_("li",[v._v("对每一个元素："),_("code",[v._v("Mono#delayElement")]),v._v("，"),_("code",[v._v("Flux#delayElements")])]),v._v(" "),_("li",[v._v("延迟订阅："),_("code",[v._v("delaySubscription")])])])])]),v._v(" "),_("h2",{attrs:{id:"拆分-flux"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拆分-flux"}},[v._v("#")]),v._v(" 拆分 "),_("code",[v._v("Flux")])]),v._v(" "),_("ul",[_("li",[v._v("我想将一个 "),_("code",[v._v("Flux<T>")]),v._v(" 拆分为一个 "),_("code",[v._v("Flux<Flux<T>>")]),v._v("：\n"),_("ul",[_("li",[v._v("以个数为界："),_("code",[v._v("window(int)")]),v._v(" "),_("ul",[_("li",[v._v("会出现重叠或丢弃的情况："),_("code",[v._v("window(int, int)")])])])]),v._v(" "),_("li",[v._v("以时间为界："),_("code",[v._v("window(Duration)")]),v._v(" "),_("ul",[_("li",[v._v("会出现重叠或丢弃的情况："),_("code",[v._v("window(Duration, Duration)")])])])]),v._v(" "),_("li",[v._v("以个数或时间为界："),_("code",[v._v("windowTimeout(int, Duration)")])]),v._v(" "),_("li",[v._v("基于对元素的判断条件："),_("code",[v._v("windowUntil")]),v._v(" "),_("ul",[_("li",[v._v("触发判断条件的元素会分到下一波（"),_("code",[v._v("cutBefore")]),v._v(" 变量）："),_("code",[v._v(".windowUntil(predicate, true)")])]),v._v(" "),_("li",[v._v("满足条件的元素在一波，直到不满足条件的元素发出开始下一波："),_("code",[v._v("windowWhile")]),v._v(" （不满足条件的元素会被丢弃）")])])]),v._v(" "),_("li",[v._v("通过另一个 Publisher 的每一个 onNext 信号来拆分序列："),_("code",[v._v("window(Publisher)")]),v._v("，"),_("code",[v._v("windowWhen")])])])]),v._v(" "),_("li",[v._v("我想将一个 "),_("code",[v._v("Flux<T>")]),v._v(" 的元素拆分到集合\n"),_("ul",[_("li",[v._v("拆分为一个一个的 "),_("code",[v._v("List")]),v._v(":\n"),_("ul",[_("li",[v._v("以个数为界："),_("code",[v._v("buffer(int)")]),v._v(" "),_("ul",[_("li",[v._v("会出现重叠或丢弃的情况："),_("code",[v._v("buffer(int, int)")])])])]),v._v(" "),_("li",[v._v("以时间为界："),_("code",[v._v("buffer(Duration)")]),v._v(" "),_("ul",[_("li",[v._v("会出现重叠或丢弃的情况："),_("code",[v._v("buffer(Duration, Duration)")])])])]),v._v(" "),_("li",[v._v("以个数或时间为界："),_("code",[v._v("bufferTimeout(int, Duration)")])]),v._v(" "),_("li",[v._v("基于对元素的判断条件："),_("code",[v._v("bufferUntil(Predicate)")]),v._v(" "),_("ul",[_("li",[v._v("触发判断条件的元素会分到下一个buffer："),_("code",[v._v(".bufferUntil(predicate, true)")])]),v._v(" "),_("li",[v._v("满足条件的元素在一个buffer，直到不满足条件的元素发出开始下一buffer："),_("code",[v._v("bufferWhile(Predicate)")])])])]),v._v(" "),_("li",[v._v("通过另一个 Publisher 的每一个 onNext 信号来拆分序列："),_("code",[v._v("buffer(Publisher)")]),v._v("，"),_("code",[v._v("bufferWhen")])])])]),v._v(" "),_("li",[v._v('拆分到指定类型的 "collection"：'),_("code",[v._v("buffer(int, Supplier<C>)")])])])]),v._v(" "),_("li",[v._v("我想将 "),_("code",[v._v("Flux<T>")]),v._v(" 中具有共同特征的元素分组到子 Flux："),_("code",[v._v("groupBy(Function<T,K>)")]),v._v(" TIP：注意返回值是 "),_("code",[v._v("Flux<GroupedFlux<K, T>>")]),v._v("，每一个 "),_("code",[v._v("GroupedFlux")]),v._v(" 具有相同的 key 值 "),_("code",[v._v("K")]),v._v("，可以通过 "),_("code",[v._v("key()")]),v._v(" 方法获取。")])]),v._v(" "),_("h2",{attrs:{id:"回到同步的世界"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回到同步的世界"}},[v._v("#")]),v._v(" 回到同步的世界")]),v._v(" "),_("ul",[_("li",[v._v("我有一个 "),_("code",[v._v("Flux<T>")]),v._v("，我想：\n"),_("ul",[_("li",[v._v("在拿到第一个元素前阻塞："),_("code",[v._v("Flux#blockFirst")]),v._v(" "),_("ul",[_("li",[v._v("并给出超时时限："),_("code",[v._v("Flux#blockFirst(Duration)")])])])]),v._v(" "),_("li",[v._v("在拿到最后一个元素前阻塞（如果序列为空则返回 null）："),_("code",[v._v("Flux#blockLast")]),v._v(" "),_("ul",[_("li",[v._v("并给出超时时限："),_("code",[v._v("Flux#blockLast(Duration)")])])])]),v._v(" "),_("li",[v._v("同步地转换为 "),_("code",[v._v("Iterable<T>")]),v._v("："),_("code",[v._v("Flux#toIterable")])]),v._v(" "),_("li",[v._v("同步地转换为 Java 8 "),_("code",[v._v("Stream<T>")]),v._v("："),_("code",[v._v("Flux#toStream")])])])]),v._v(" "),_("li",[v._v("我有一个 "),_("code",[v._v("Mono<T>")]),v._v("，我想：\n"),_("ul",[_("li",[v._v("在拿到元素前阻塞："),_("code",[v._v("Mono#block")]),v._v(" "),_("ul",[_("li",[v._v("并给出超时时限："),_("code",[v._v("Mono#block(Duration)")])])])]),v._v(" "),_("li",[v._v("转换为 "),_("code",[v._v("CompletableFuture<T>")]),v._v("："),_("code",[v._v("Mono#toFuture")])])])])])])}),[],!1,null,null,null);_.default=o.exports}}]);